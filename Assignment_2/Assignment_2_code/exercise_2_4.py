# -*- coding: utf-8 -*-
"""Exercise_2_4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ngT2cVNQToIYiIRdpSgdB6iae-7Kmy2L

#Exercise 2.4
An observer	has	completed	50 trials	in an	auditory,	a	visual and an	audio-visual spatial localisation	task.	The	data is	in files xA, xV	and	xAV. Fit the strong fusion model to	the	data.	Remember to	use	all	the	data to estimate the parameters.
"""

#pip install lmfit

#For Imports
import numpy as np
import matplotlib.pyplot as plt
import math
from scipy.stats import norm
from scipy import optimize
from sklearn.preprocessing import normalize
from lmfit import minimize, Parameters, report_fit

from google.colab import drive
drive.mount('/content/drive/')

!ls drive/'My Drive'/'Cognitive modelling'
path_to_data = 'drive/My Drive/Cognitive modelling'

#Load the text files into numpy arrays
xA = np.loadtxt(path_to_data + '/xA.txt')
xAV = np.loadtxt(path_to_data + '/xAV.txt')
xV = np.loadtxt(path_to_data + '/xV.txt')
xAlapse = np.loadtxt(path_to_data + '/xAlapse.txt')
xAVlapse = np.loadtxt(path_to_data + '/xAVlapse.txt')
xVlapse = np.loadtxt(path_to_data + '/xVlapse.txt')

def fun(params, xA, xV, xAV):
  muA = params[0]
  sigmaA = params[1]
  muV = params[2]
  sigmaV = params[3]
  sigma2A = params[1]**2
  sigma2V = params[3]**2

  wA = sigma2V / (sigma2A + sigma2V)

  muAV = wA*muA + (1-wA)*muV
  sigmaAV = math.sqrt(sigma2A*sigma2V/(sigma2A+sigma2V))
  negLL = -np.sum(np.log(norm.pdf(xA,muA,sigmaA))) - np.sum(np.log(norm.pdf(xV,muV,sigmaV))) - np.sum(np.log(norm.pdf(xAV,muAV,sigmaAV)))
  
  return negLL

params0 = np.array([np.mean(xA), np.std(xA), np.mean(xV), np.std(xV)])

xopt = optimize.fmin(fun, x0=params0, args=(xA, xV, xAV))

muAopt = xopt[0]
sigmaAopt = xopt[1]
muVopt = xopt[2]
sigmaVopt = xopt[3]

wAopt = sigmaVopt**2 / (sigmaAopt**2 + sigmaVopt**2)
muAVopt = wAopt*muAopt + (1-wAopt)*muVopt
sigmaAVopt = math.sqrt(sigmaAopt**2*sigmaVopt**2/(sigmaAopt**2+sigmaVopt**2))

print(f'muAopt: {muAopt}\n')
print(f'sigmaAopt: {sigmaAopt}\n')
print(f'muVopt: {muVopt}\n')
print(f'sigmaVopt: {sigmaVopt}\n')
print(f'muAVopt: {muAVopt}\n')
print(f'sigmaAVopt: {sigmaAVopt}\n')

xnew = np.arange(-25, 35, 0.1)
plt.figure(figsize=(20,6))

plt.hist(xA, bins= 8, density=True, color = 'r', rwidth = 0.85)
plt.plot(xnew, norm.pdf(xnew, muAopt, sigmaAopt))
plt.hist(xV,bins= 8, density=True, color = 'y', rwidth = 0.85)
plt.plot(xnew, norm.pdf(xnew, muVopt, sigmaVopt))
plt.hist(xAV,bins= 8, density=True, color = 'g', rwidth = 0.85)
plt.plot(xnew, norm.pdf(xnew, muAVopt, sigmaAVopt))

params0lapse = np.array([np.mean(xAlapse), np.std(xAlapse), np.mean(xVlapse), np.std(xVlapse)])
print(params0lapse)

xoptlapse = optimize.fmin(fun, x0=params0lapse, args=(xAlapse, xVlapse, xAVlapse))

muAoptlapse = xoptlapse[0]
sigmaAoptlapse = xoptlapse[1]
muVoptlapse = xoptlapse[2]
sigmaVoptlapse = xoptlapse[3]

wAoptlapse = sigmaVoptlapse**2 / (sigmaAoptlapse**2 + sigmaVoptlapse**2)
muAVoptlapse = wAoptlapse*muAoptlapse + (1-wAoptlapse)*muVoptlapse
sigmaAVoptlapse = math.sqrt(sigmaAoptlapse**2*sigmaVoptlapse**2/(sigmaAoptlapse**2+sigmaVoptlapse**2))

print(f'muAoptlapse: {muAoptlapse}\n')
print(f'sigmaAoptlapse: {sigmaAoptlapse}\n')
print(f'muVoptlapse: {muVoptlapse}\n')
print(f'sigmaVoptlapse: {sigmaVoptlapse}\n')
print(f'muAVoptlapse: {muAVoptlapse}\n')
print(f'sigmaAVoptlapse: {sigmaAVoptlapse}\n')

plt.figure(figsize=(20,6))

plt.hist(xAlapse, bins= 12, density=True, color = 'r', rwidth = 0.85)
plt.plot(xnew, norm.pdf(xnew, muAoptlapse, sigmaAoptlapse))
plt.hist(xVlapse,bins= 12, density=True, color = 'y', rwidth = 0.85)
plt.plot(xnew, norm.pdf(xnew, muVoptlapse, sigmaVoptlapse))
plt.hist(xAVlapse,bins= 12, density=True, color = 'g', rwidth = 0.85)
plt.plot(xnew, norm.pdf(xnew, muAVoptlapse, sigmaAVoptlapse))

